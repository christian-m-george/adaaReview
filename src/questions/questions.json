{
  "questions": [
    {
      "type": "mc",
      "question": "A binary heap is a nearly complete binary tree filled on all levels except possibly the lowest level where leaves are pushed left-most. Heaps are usually implemented as an array. If a binary heap contains 100 elements (nodes), what is the height of the corresponding binary tree?",
      "answers": [
        { "text": "n", "correct": false },
        { "text": "7", "correct": true },
        { "text": "O(n)", "correct": false },
        { "text": "9", "correct": false },
        { "text": "100", "correct": false }
      ]
    },
    {
      "type": "sa",
      "question": "A binary heap is a nearly complete binary tree filled on all levels except possibly the lowest level where leaves are pushed left-most. Heaps are usually implemented as an array. An array A that represents a heap is an object with two attributes. What are the two attributes needed?",
      "answers": ["array length", "heap size"]
    },
    {
      "type": "mc",
      "question": "A Tree is an abstract data type.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A Tree is a data structure.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "An Array is a data structure.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A List is a data structure.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "sa",
      "question": "A 2-3 tree is a tree in which each vertex which is not a leaf has 2 or 3 sons, and every path from the root to a leaf is of the same length. What is the range of the number of leaves in a 2-3 tree of height h?.",
      "answers": ["2^h", "3^h"]
    },
    {
      "type": "mc",
      "question": "A 2-3 tree is a tree in which each vertex which is not a leaf has 2 or 3 sons, and every path from the root to a leaf is of the same length. The time to find an element in 2-3 tree is proportional to the height of the tree. If a 2-3 tree has n elements, what is the search time in O-notation in terms of n?",
      "answers": [
        { "text": "n", "correct": false },
        { "text": "O(log n)", "correct": true },
        { "text": "O(n)", "correct": false },
        { "text": "3", "correct": false },
        { "text": "2", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Inserting an element into a heap takes O(1) runtime.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "The minimum in a min-heap can be found in O(1) runtime.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "If the maximum in a heap is the first element, then the minimum in this heap must be the last element.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "The minimum in a min-heap can be found in O(n) runtime.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A Queue is an abstract data type.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A Stack is an abstract data type.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. The size of the left subtree must be larger than the size of the right subtree since nodes must be pushed left.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. The key of a node N is larger than the keys of its left and right children.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. What is the relationship between the key of a node and the key of its right child?",
      "answers": [
        { "text": "node.key <= node.right.key ", "correct": false },
        { "text": "node.key > node.right.key ", "correct": false },
        { "text": "node.key >= node.right.key ", "correct": false },
        { "text": "node.key < node.right.key ", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. Find/Search/Get in a binary search tree with n nodes always has runtime of O(log n) regardless of insertion order.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False ", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. Find/Search/Get in a binary search tree with n nodes has an expected runtime of O(log n) for balanced trees.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. Find/Search/Get in a binary search tree with n nodes and height h always has runtime of O(h).",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. If the left child exists then the predecessor of Node N is the maximum in the tree rooted at the left child.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. If the right child exists then the successor of Node N is the minimum in the tree rooted at the right child.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. If the right child exists then the successor of Node N is the maximum in the tree rooted at the right child.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False ", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. We can find the minimum by following the right child pointers from root until we encounter a leaf.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False ", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. In-order walks provide the correct order regardless of the tree balance.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Find/Search/Get in a binary search tree with n nodes and height h always has runtime of O(h) regardless of insertion order.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. What is the relationship between the key of a node and the key of its right child?",
      "answers": [
        { "text": "node.right.key < node.key", "correct": false },
        { "text": "node.right.key = node.key", "correct": false },
        { "text": "node.right.key > node.key", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Recall that a self-balancing tree is a search tree data structure in which insert/delete operations may trigger a partial rebuild of the tree. Select self-balancing search tree data structures discussed/presented in class.",
      "answers": [
        { "text": "AVL Tree ", "correct": false },
        { "text": "Binary Search Tree", "correct": false },
        { "text": "Red-Black Trees", "correct": true },
        { "text": "Splay Trees", "correct": false },
        { "text": "AA Tree", "correct": false },
        { "text": "B Tree", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Recall that a self-balancing tree is a search tree data structure in which insert/delete operations may trigger a partial rebuild of the tree. Select the correct statements about self-balancing trees.",
      "answers": [
        {
          "text": "Self-balancing trees may transform part of the tree at insertion to keep the height proportional to log2(n).",
          "correct": true
        },
        {
          "text": "Self-balancing trees rebuild the whole tree for every insertion to keep the height minimal.",
          "correct": false
        },
        {
          "text": "Self-balancing trees rebuild the whole tree after some delete operations to keep the height minimal.",
          "correct": true
        },
        { "text": "Splay Trees", "correct": false },
        {
          "text": "Self-balancing trees perform an in-order walk upon an insert operation.",
          "correct": true
        },
        {
          "text": "Self-balancing trees rebuild the tree when height is larger than 2 log2(n)",
          "correct": false
        }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees were introduced by one of the co-authors of our text book.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees were the first self-balancing trees introduced.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees are binary search trees.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees store the size of the subtree rooted at a node in that node.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A measure of balance is the parameter 𝛼. For a Scapegoat tree, 𝛼⋅size(node) ≤ size(left[node])",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A measure of balance is the parameter 𝛼. For a Scapegoat tree, size(right[node]) ≤ 𝛼⋅size(node)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A measure of balance is the parameter 𝛼. For a Scapegoat tree, size(left[node]) ≤ 𝛼⋅size(node)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "If 𝑇 is an 𝛼-weight-balanced binary search tree then 𝑇 is also 𝛼-height-balanced.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "If 𝑇 is an 𝛼-weight-balanced binary search tree then 𝑇 is also 𝛼-height-balanced.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Hash tables are an implementation of the ADT dictionary. They are arrays which utilize hash functions. What do we call it when two keys are mapped to the same hash value?",
      "answers": [
        { "text": "Collision", "correct": true },
        { "text": "Hashing", "correct": false },
        { "text": "Same", "correct": false },
        { "text": "KeyOutOfBoundError", "correct": false },
        { "text": "Chaining", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A hash function has fixed input and output size.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "sa",
      "question": "If we implement a hash table as an array of size 1024, what does the output of our hash function have to satisfy (related to the definition of a hash function) in order for our program not to constantly crash?",
      "answers": ["valid index"]
    },
    {
      "type": "mc",
      "question": "When two keys are mapped to the same hash value, what is the name of the method to store data in the corresponding array entry?",
      "answers": [
        { "text": "Chaining", "correct": true },
        { "text": "Duplication", "correct": false },
        { "text": "Hashing", "correct": false },
        { "text": "KeyOutOfBoundError", "correct": false },
        { "text": "Collision", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A hash function has fixed output size.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A hash function has a fixed input size.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Select the methods which a hash table implements.",
      "answers": [
        { "text": "Sort", "correct": false },
        { "text": "Insert", "correct": true },
        { "text": "Delete", "correct": true },
        { "text": "Min", "correct": false },
        { "text": "Find", "correct": true },
        { "text": "Predecessor", "correct": false }
      ]
    },
    {
      "type": "sa",
      "question": "Name the amortization analysis methods discussed  in class.",
      "answers": ["amortization", "aggregate", "potential"]
    },
    {
      "type": "mc",
      "question": "If we have an algorithm A for a problem P and this algorithm is of complexity O(n) then the problem P is of complexity at least O(n).",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "The complexity of an algorithm A which solves a problem P is an upper bound on the complexity of P.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "If we have an algorithm A for a problem P and this algorithm is of complexity O(n) then the problem P is of complexity O(n).",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Θ provides a tight bound.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Ω provides an asymptotic lower bound.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "O provides an asymptotic upper bound.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Ω provides an asymptotic upper bound.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "All objects/elements may be represented by integers.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Union-Find data structures may be implemented using a list of trees.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Union-Find data structures may be implemented using one singly-linked list.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "The find operation returns a random element from the set the element belongs to.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "sa",
      "question": "Name two applications for Union-Find structures.",
      "answers": ["social media", "nsa"]
    },
    {
      "type": "sa",
      "question": "Name two improvements that can be used on QuickUnion and QuickFind (one each) to get a better worst-case run-time.",
      "answers": ["weighted", "compress"]
    },
    {
      "type": "sa",
      "question": "A binary heap is a nearly complete binary tree filled on all levels except possibly the lowest level where leaves are pushed left-most. Heaps are usually implemented as an array. Each node in a heap satisfies the heap property. What is the name of a heap in which every node’s value is less than (or equal to) the values of its children?",
      "answers": ["min-heap"]
    },
    {
      "type": "mc",
      "question": "A Queue is a data structure.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A Stack is a data structure.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Removing the root in a heap takes O(log n) runtime.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. All keys of nodes in the left subtree of a node N are smaller than the key of N.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. What is the relationship between the key of a node and the key of its left child?",
      "answers": [
        { "text": "node.left.key < node.key ", "correct": true },
        { "text": "node.left.key > node.key ", "correct": false },
        { "text": "node.left.key >= node.key ", "correct": false },
        { "text": "node.left.key <= node.key", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. Find/Search/Get in a binary search tree with n nodes and height h has worst-case runtime of O(n).",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. Left and right children are roots of left and right subtrees, respectively. We can find the maximum by following the left child pointers from root until we encounter a leaf.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A binary search tree (BST) is a linked-node based binary tree which stores key-value pairs (or just keys) in each node. What is the relationship between the key of a node and the key of its left child?",
      "answers": [
        { "text": "node.left.key < node.key  ", "correct": true },
        { "text": "node.left.key > node.key  ", "correct": false },
        { "text": "node.left.key = node.key  ", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees store the size of the tree in the root.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A Scapegoat tree provides worst-case O(log(n)) lookup time for a tree with n nodes.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A measure of balance is the parameter 𝛼. For a Scapegoat tree, 0 <= 𝛼 <= 1/2 .",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. A measure of balance is the parameter 𝛼. For a Scapegoat tree, 𝛼⋅size(node) ≤ size(right[node])",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees are search trees which upon insert/delete operations rarely but expensively choose a scapegoat node and completely rebuild the subtree rooted at it into a complete tree. The following is a True/False question about Scapegoat trees. Scapegoat trees store the size of the tree in the root.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Hash tables utilize hash functions. Hash functions have certain properties. A hash function has fixed input size.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "The complexity of an algorithm 𝐴 which solves a problem 𝑃 is a lower bound on the complexity of 𝑃.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Any comparison sort algorithm requires 𝛺(𝑛log𝑛) comparisons in the worst case.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Θ provides an asymptotic upper bound.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Union-Find data structures may be implemented using one array.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A Union-Find data structure stores a collection of disjoint sets.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "The union operation merges all elements of the data structure.",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "An ADT defines the behavior of a data implementation from the point of the User.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "An data structure a representation of the data (organization, storage, and management) from the point of the programmer.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "An ADT can have several data structures associated with it.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "An ADT is implementation dependent.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "An data structure a representation of the data (organization, storage, and management) from the point of the programmer.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "sa",
      "question": "An array that implements a heap is usually of length power-of-two. If a heap has size 126, what is the minimum sizwe of the corresponding array?",
      "answers": ["126"]
    },
    {
      "type": "sa",
      "question": "A binary heap contains 28 nodes. What is the height of the corresponding array?",
      "answers": ["5"]
    },
    {
      "type": "mc",
      "question": "A data structure a representation of the data (organization, storage, and management) from the point of the programmer.",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "sa",
      "question": "If a heap is implemented in an array, and the maximum in that heap is the first element of the array, what type of heap is it?",
      "answers": ["max-heap"]
    },
    {
      "type": "mc",
      "question": "In a 2-3 tree, each node is labeled with the smallest value in the left subree and the largest value in the right subtree",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "In a 2-3 tree, every path from the root to a leaf has length 2 or length 3",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "In a 2-3 tree, data is only stored in the leaves",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "In a 2-3 tree, data is ordered left to right",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "BSTs form doubly linked lists",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "In a BST, all keys of nodes in the right subtree of a node N are smaller than the key of N",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "In a BST, keys must be integers",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "The minimum key in a BST is the root",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Post order walks provide the correct key order regardless of balance",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A BST with n nodes has height at least log base 2 of n",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Keys in a BST must be comparable",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "sa",
      "question": "Name 4 types of self balancing trees",
      "answers": ["red black", "avl", "scapegoat", "splay"]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees store the height of the whole tree in the root",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees store the height of the subtree rooted at node N that node N",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees store the weight of the subree rooted at node N in that node N",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "A measure of tree balance is the parameter α. For a Scapegoat tree size(left[node]) ≤ α size(node) ",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A measure of tree balance is the parameter α. For a Scapegoat tree 1/2 ≤ α ≤ 1 ",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "If a partial tree rebuild is triggered by insertion of of a deep node N, the scapegoat node is an ancestor of the Node N",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "The roots of th etrees in a Fibonacci heap are stored in a doubly linked list",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Fibonacci heaps consolidate trees after each delete_min operation",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Nodes in a Fibonacci heap have parent pointers",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "A node N in a Fibonacci heap has pointers to each of its children",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Find/search/get in an array with n nodes always has runtime of O(n)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "In a BST with n nodes, the BST key property affords us to retrieve all data in order in O(n)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Find/search/get in a BST with n nodes and height h always has runtime O(log n)",
      "answers": [
        { "text": "True", "correct": false },
        { "text": "False", "correct": true }
      ]
    },
    {
      "type": "mc",
      "question": "Find/search/get in a 2-3 tree with n nodes always has runtime of O(log n)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Scapegoat trees achieve O(log n) amortized runtime complexity for all operations insert, delete, search",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Delete_min in a Fibonacci heap has amortized runtime O(log n)",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Amortization is used for the evaluation of a sequence of operations",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    },
    {
      "type": "mc",
      "question": "Amortized analysis evaluates the average cost",
      "answers": [
        { "text": "True", "correct": true },
        { "text": "False", "correct": false }
      ]
    }
  ]
}
